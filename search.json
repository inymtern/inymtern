[{"title":"【Linux】docker使用","url":"/2022/12/03/docker%E4%BD%BF%E7%94%A8/","content":"\n查看镜像\n\ndocker images\n\n\n\n\n拉取镜像\n\ndocker pull mysql:latest\n\n\n\n\n删除镜像\n\ndocker rmi mysql:latest\n\n\n\n\n创建实例（前主机后容器）\n\ndocker run -d -p 33306:3306 -v &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d -v &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;INYMTERNcl,.123 –name  mysql mysql:latest\n\n\n\n\n查看实例运行日志\n\ndocker logs mysql\n\n\n\n\n进入容器\n\ndocker exec -it mysql bash\n\n\n\n\n停止实例运行\n\ndocker stop mysql\n\n\n\n\n删除实例\n\ndocker rm mysql\n\n\n\n\n\n","tags":["Linux","Docker"]},{"title":"【Linux】jar包启动","url":"/2022/12/03/jar%E5%8C%85%E5%90%AF%E5%8A%A8/","content":"启动\n\n nohup java -jar test.jar &gt; log.file 2&gt;&amp;1 &amp;\n\n指定参数\n\n nohup java -jar test.jar –server.port&#x3D;8181 –spring.profiles.active&#x3D;dev &gt; log.file 2&gt;&amp;1 &amp;\n\n不保留日志（传送到黑洞）\n\n nohup java -jar &#x2F;usr&#x2F;local&#x2F;jar&#x2F;test.jar &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;\n\n","tags":["Linux","Java"]},{"title":"【Java】类通用构建器","url":"/2022/11/27/%E3%80%90Java%E3%80%91%E7%B1%BB%E9%80%9A%E7%94%A8%E6%9E%84%E5%BB%BA%E5%99%A8/","content":"EntityCreator实现\n对于构建者模式，每个内部 Builder 类要对每个字段建立相应方法，代码比较冗长。若将「构建机制」独立出来，或能广泛适应相似结构的构建需求。\n\nclass EntityCreator&lt;T&gt; &#123;    private Class&lt;T&gt; classInstance;    private T entityObj;    public EntityCreator(Class&lt;T&gt; classInstance, Object... initParams) throws Exception &#123;        this.classInstance = classInstance;        Class&lt;?&gt;[] paramTypes = new Class&lt;?&gt;[initParams.length];        for (int index = 0, length = initParams.length; index &lt; length; index++) &#123;            String checkStr = initParams[index].getClass().getSimpleName();            if (checkStr.contains(&quot;Integer&quot;)) &#123;                paramTypes[index] = int.class;            &#125;            if (checkStr.contains(&quot;Double&quot;)) &#123;                paramTypes[index] = double.class;            &#125;            if (checkStr.contains(&quot;Boolean&quot;)) &#123;                paramTypes[index] = boolean.class;            &#125;            if (checkStr.contains(&quot;String&quot;)) &#123;                paramTypes[index] = initParams[index].getClass();            &#125;        &#125;        Constructor&lt;T&gt; constructor = classInstance.getDeclaredConstructor(paramTypes);        constructor.setAccessible(true);        this.entityObj = constructor.newInstance(initParams);    &#125;    /**     * 方法引用set     * @param biConsumer     * @param paramValue     * @return     * @param &lt;P&gt;     * @throws Exception     */    public &lt;P&gt; EntityCreator&lt;T&gt; setValue(BiConsumer&lt;T, P&gt; biConsumer, P paramValue) throws Exception &#123;        biConsumer.accept(entityObj, paramValue);        return this;    &#125;    /**     * 反射式set     * @param paramName     * @param paramValue     * @return     * @throws Exception     */    public EntityCreator&lt;T&gt; setValue(String paramName, Object paramValue) throws Exception &#123;        Field field = classInstance.getDeclaredField(paramName);        field.setAccessible(true);        field.set(entityObj, paramValue);        return this;    &#125;    public T build() &#123;        return entityObj;    &#125;&#125;\n\n测试@Datapublic class Test &#123;    private String name;    private Integer age;    public static void main(String[] args) throws Exception &#123;        Test test = new EntityCreator&lt;Test&gt;(Test.class)                .setValue(Test::setName, &quot;ZhangSan&quot;)                .setValue(Test::setAge, 12).build();        System.out.println(test);    &#125;&#125;","tags":["Java","Builder","EffectiveJava"]},{"title":"【Linux】mysql开启远程访问","url":"/2022/12/03/mysql%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/","content":"1.登录mysql\n\nmysql -uroot -p\n\n2.授权\n\nGRANT ALL ON . TO ‘root‘@’%’;\n\n3.刷新权限\n\nflush privileges;\n\n","tags":["Linux","Docker","MySql"]},{"title":"【Linux】安装docker","url":"/2022/12/03/%E5%AE%89%E8%A3%85docker/","content":"1. 设置源\n\nyum-config-manager –add-repo https://download.docker.com/linux/centos/docker-ce.repo\n\n2. docker 所有版本\n\nyum list docker-ce –showduplicates | sort -r\n\n3. 安装(y)\n\nyum install docker-ce\n\n4. 验证\n\ndocker version\n\n5. 启动\n\nsystemctl start docker \n\n6. 加入自启动\n\nsystemctl enable docker\n\n","tags":["Linux","Docker"]},{"title":"【Linux】安装jdk","url":"/2022/12/03/%E5%AE%89%E8%A3%85jdk/","content":"查看是否已安装\n\nrpm -qa |grep java\n\n如已安装卸载\n\nrpm -qa | grep java | xargs rpm -e –nodeps\n\n使用 yum 安装\n\nyum install java-1.8.0-openjdk* -y\n\n验证是否安装成功\n\n java -version\n\n","tags":["Linux","Java"]},{"title":"【Linux】安装git","url":"/2022/12/03/%E5%AE%89%E8%A3%85git/","content":"安装\n\nyum -y install git\n\n安装目录\n\n&#x2F;usr&#x2F;libexec&#x2F;git-core\n\n配置用户名邮箱\n\ngit config --global user.name &quot;name&quot;git config --global user.email &quot;email&quot;\n\n生成公钥\n\n ssh-keygen -t rsa -C “&#105;&#x6e;&#x79;&#x6d;&#x74;&#101;&#114;&#x6e;&#x5f;&#x63;&#x6c;&#x40;&#49;&#50;&#x36;&#46;&#99;&#111;&#109;“\n\n","tags":["Linux","Git"]},{"title":"【Linux】安装nginx","url":"/2022/12/03/%E5%AE%89%E8%A3%85nginx/","content":"安装\n\nyum -y install nginx \n\n文件位置\n\n&#x2F;etc&#x2F;nginx&#x2F;nginx.conf                                   &#x2F;&#x2F;yum方式安装后默认配置文件的路径\n\n\n&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html                                   &#x2F;&#x2F;nginx网站默认存放目录\n\n\n&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html                        &#x2F;&#x2F;网站默认主页路径\n\n启动\n\nnginx\n\n重启\n\nnginx -s reload\n\n关闭\n\nnginx stop\n\n","tags":["Linux","Nginx"]},{"title":"【Linux】查看端口","url":"/2022/12/03/%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3/","content":"查看端口占用\n\nnetstat -tunlp | grep 3306\n\n","tags":["Linux"]},{"title":"【Linux】查看进程","url":"/2022/12/03/%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B/","content":"查看\n\nps -aux | grep java\n\n\nps -ef | grep java\n\n结束进程\n\nkill -9 进程ID\n\n","tags":["Linux"]},{"title":"【Linux】配置防火墙","url":"/2022/12/03/%E9%85%8D%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99/","content":"1、开放redis的6379端口【假设redis端口为6379】\n\nfirewall-cmd –zone&#x3D;public –add-port&#x3D;6379&#x2F;tcp –permanent\n\n2、重启防火墙使得配置生效\n\nsystemctl restart firewalld\n\n3、查看系统所有开放的端口\n\nfirewall-cmd –zone&#x3D;public –list-ports\n\n启动redis\n\nredis-server &#x2F;etc&#x2F;redis.conf –daemonize yes\n\n","tags":["Linux"]},{"title":"BeanPostProcessor接口","url":"/2023/02/03/BeanPostProcessor%E6%8E%A5%E5%8F%A3/","content":"BeanPostProcessor接口1. 描述\nBeanPostProcessor： Bean的后置处理器 \n\n\npostProcessBeforeInitialization() 实例化、依赖注入完毕 之后  初始化之前执行\n\n\npostProcessAfterInitialization() 初始化之后执行\n\n2.示例@Configurationpublic class MyBeanPostProcess implements BeanPostProcessor &#123;    @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;        System.out.println(beanName + &quot; 初始化之前.....&quot;);        return bean;    &#125;    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;        System.out.println(beanName + &quot; 初始化之后.....&quot;);        return bean;    &#125;&#125;","tags":["Java","Spring"]},{"title":"Java类链式增强Demo","url":"/2023/02/04/Java%E7%B1%BB%E9%93%BE%E5%BC%8F%E5%A2%9E%E5%BC%BADemo/","content":"\nLinkMap.classLinkMap.classpublic class LinkMap&lt;T&gt;  &#123;    private static final String TRANS_SUFFIX = &quot;Str&quot;;    private HashMap&lt;String, Object&gt; map;    public LinkMap(T t) &#123;        mapping(t);    &#125;    /**     * 添加字段     * @param name 字段名     * @param value 字段值     * @param override 相同key是否覆盖     * @return     */    public LinkMap&lt;T&gt; add(String name, Object value, boolean override) &#123;        Objects.nonNull(map);        Objects.nonNull(name);        if (map.containsKey(name) &amp;&amp; !override) return this;        map.put(name,value);        return this;    &#125;    /**     * 添加字段相同覆盖     * @param name 字段名     * @param value 字段值     * @return     */    public LinkMap&lt;T&gt; add(String name, Object value) &#123;        return add(name, value, true);    &#125;    /**     * 修改字段     * @return     */    public LinkMap&lt;T&gt; replace(String name, Object value) &#123;        Objects.nonNull(map);        Objects.nonNull(name);        if(map.containsKey(name)) &#123;            map.replace(name, value);        &#125;        return this;    &#125;    /**     * 删除字段     * @return     */    public LinkMap&lt;T&gt; remove(String... names) &#123;        Objects.nonNull(map);        for (String name : names) &#123;            map.remove(name);        &#125;        return this;    &#125;    /**     * 添加或替换翻译字段     * @param mapping 翻译表     * @param name 翻译字段     * @param replace true替换原字段 / false添加新字段 (后缀加上Str)     * @return     */    public LinkMap&lt;T&gt; translate(Map&lt;?,?&gt; mapping, String name, boolean replace) &#123;        Objects.nonNull(map);        Objects.nonNull(mapping);        Objects.nonNull(name);        if(!map.containsKey(name)) return this;        Object k = map.get(name);        if(!mapping.containsKey(k)) return this;        Object v = mapping.get(k);        String s = replace ? name : (name + TRANS_SUFFIX);        map.put(s, v);        return this;    &#125;    /**     * 添加翻译字段(name+Str)     * @param mapping 翻译表     * @param name 翻译字段     * @return     */    public LinkMap&lt;T&gt; translate(Map&lt;?,?&gt; mapping, String name) &#123;        return translate(mapping, name, false);    &#125;    /**     * 仅保留指定字段     * @param fields 保留字段     * @return     */    public LinkMap&lt;T&gt; keep(List&lt;String&gt; fields) &#123;        Objects.nonNull(map);        ArrayList&lt;String&gt; delKeys = new ArrayList&lt;&gt;();        map.keySet().forEach(s-&gt;&#123;            if (!fieldOrTranslateInList(fields, s)) &#123;                delKeys.add(s);            &#125;        &#125;);        for (String s : delKeys) &#123;            map.remove(s);        &#125;        return this;    &#125;    private boolean fieldOrTranslateInList(List&lt;String&gt; fields, String field) &#123;        return fields.contains(field) || translateInList(fields, field);    &#125;    private boolean translateInList(List&lt;String&gt; fields, String field) &#123;        if (!field.endsWith(TRANS_SUFFIX)) return false;        return fields.contains(field.substring(0, field.length()-TRANS_SUFFIX.length()));    &#125;    public HashMap&lt;String, Object&gt; build() &#123;        return map;    &#125;    /**     * 将T对象字段映射至map     * @param t     */    private void mapping(T t) &#123;        Objects.nonNull(t);        map = new HashMap&lt;&gt;();        for (Field field : t.getClass().getDeclaredFields()) &#123;            field.setAccessible(true);            Object o = null;            try &#123;                o = field.get(t);            &#125; catch (IllegalAccessException e) &#123;            &#125;            if(o == null) continue;            String name = field.getName();            map.put(name, o);        &#125;    &#125;&#125;\n\nLinkFace.classLinkFace.classpublic interface LinkFace&lt;T&gt; &#123;    default LinkMap&lt;T&gt; linkMap() &#123;        return new LinkMap&lt;T&gt;((T) this);    &#125;&#125;\n\nTest1.classTest1.classpublic class Test1 implements LinkFace&lt;Test1&gt; &#123;    private Integer age;    private String name;&#125;\n\n\nTestMainHashMap&lt;Integer, String&gt; mapping = new HashMap&lt;&gt;();mapping.put(1, &quot;小学&quot;);mapping.put(2, &quot;中学&quot;);mapping.put(3, &quot;高中&quot;);HashMap&lt;String, Object&gt; obj = new Test1(1,&quot;TOM&quot;)        .linkMap()        .add(&quot;address&quot;, &quot;The Place&quot;)        .add(&quot;createDate&quot;, &quot;2022-09-19 09:00:00&quot;)        .replace(&quot;createDate&quot;, &quot;2023-09-19 19:00:00&quot;)        .translate(mapping, &quot;age&quot;)        .keep(Arrays.asList(&quot;age&quot;, &quot;createDate&quot;, &quot;name&quot;) )        .build();System.out.println(JSON.toJSONString(obj));\n\n","tags":["Java","Careful"]},{"title":"Java执行命令行","url":"/2023/01/30/Java%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%A1%8C/","content":"Windows执行单语句public static String executeCommandAndGetResult(String command) &#123;    try &#123;        Runtime runtime = Runtime.getRuntime();        Process process = runtime.exec(&quot;cmd /c &quot; + command);        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));        StringBuilder result = new StringBuilder();        String line;        while ((line = reader.readLine()) != null) &#123;            result.append(line).append(&quot;\\n&quot;);        &#125;        int exitValue = process.waitFor();        if (exitValue == 0) &#123;            System.out.println(&quot;Command was executed successfully.&quot;);            return result.toString();        &#125; else &#123;            System.out.println(&quot;Command was executed with errors. Exit value: &quot; + exitValue);            return null;        &#125;    &#125; catch (Exception e) &#123;        System.out.println(&quot;An error occurred while executing the command: &quot; + e.getMessage());        return null;    &#125;&#125;\nWindows执行.bat文件public static String executeCommandsAndGetResult(String batchFilePath) &#123;    try &#123;        Runtime runtime = Runtime.getRuntime();        Process process = runtime.exec(&quot;cmd /c &quot; + batchFilePath);        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));        StringBuilder result = new StringBuilder();        String line;        while ((line = reader.readLine()) != null) &#123;            result.append(line).append(&quot;\\n&quot;);        &#125;        int exitValue = process.waitFor();        if (exitValue == 0) &#123;            System.out.println(&quot;Commands were executed successfully.&quot;);            return result.toString();        &#125; else &#123;            System.out.println(&quot;Commands were executed with errors. Exit value: &quot; + exitValue);            return null;        &#125;    &#125; catch (Exception e) &#123;        System.out.println(&quot;An error occurred while executing the commands: &quot; + e.getMessage());        return null;    &#125;&#125;\n\nLinux执行.shpublic static String executeCommandsAndGetResult(String shellScriptPath) &#123;      try &#123;          Runtime runtime = Runtime.getRuntime();          Process process = runtime.exec(&quot;/bin/sh &quot; + shellScriptPath);          BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));          StringBuilder result = new StringBuilder();          String line;          while ((line = reader.readLine()) != null) &#123;              result.append(line).append(&quot;\\n&quot;);          &#125;          int exitValue = process.waitFor();          if (exitValue == 0) &#123;              System.out.println(&quot;Commands were executed successfully.&quot;);              return result.toString();          &#125; else &#123;              System.out.println(&quot;Commands were executed with errors. Exit value: &quot; + exitValue);              return null;          &#125;      &#125; catch (Exception e) &#123;          System.out.println(&quot;An error occurred while executing the commands: &quot; + e.getMessage());          return null;      &#125;  &#125;","tags":["Linux","Java"]},{"title":"Spring Bean初始化","url":"/2023/02/03/SpringBean%E5%88%9D%E5%A7%8B%E5%8C%96/","content":"Spring Bean几种初始化方式1. 使用@PostConstruct注解@Servicepublic class AService &#123;    @PostConstruct    public void init() &#123;        System.out.println(&quot;===初始化===&quot;);    &#125;&#125;\n\n2. 实现 InitializingBean 接口@Servicepublic class BService implements InitializingBean &#123;    @Override    public void afterPropertiesSet() throws Exception &#123;        System.out.println(&quot;===初始化===&quot;);    &#125;&#125;\n3. 使用@Bean注解BeanCfg.class@Configurationpublic class BeanCfg &#123;    @Bean(initMethod = &quot;init&quot;)    public TestA testA() &#123;        return new TestA();    &#125;&#125;\n\nTestA.classpublic class TestA &#123;    public void init() &#123;        System.out.println(&quot;TestA 初始化&quot;);    &#125;&#125;","tags":["Java","Spring"]},{"title":"查看端口进程","url":"/2023/01/30/%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E8%BF%9B%E7%A8%8B/","content":"查看8000端口进程lsof -i:8000\npid杀死进程kill -9 &lt;pid&gt;","tags":["Linux"]},{"title":"MyBatis注解式resultMap","url":"/2023/02/21/MyBatis%E6%B3%A8%E8%A7%A3%E5%BC%8FresultMap/","content":"&#x2F;&#x2F; TODO\nhttps://www.jianshu.com/p/90592d61c800\n","tags":["Spring","MyBatis"]},{"title":"mybatis拦截器实现对SQL增强(数据权限控制)","url":"/2023/02/16/mybatis%E6%8B%A6%E6%88%AA%E5%99%A8/","content":"DEMO@Configurationpublic class PowerInterceptor implements InnerInterceptor &#123;    @Override    public boolean willDoQuery(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;        return InnerInterceptor.super.willDoQuery(executor, ms, parameter, rowBounds, resultHandler, boundSql);    &#125;//    @Override//    public void beforeQuery(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;//        InnerInterceptor.super.beforeQuery(executor, ms, parameter, rowBounds, resultHandler, boundSql);//    &#125;    @Override    public void beforeQuery(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;        PluginUtils.MPBoundSql mpBs = PluginUtils.mpBoundSql(boundSql);        String sql = mpBs.sql();        mpBs.sql(parseSingle(sql, null));    &#125;    private String parseSingle(String sql, Object obj) &#123;        Statement statement = null;        try &#123;            statement = CCJSqlParserUtil.parse(sql);        &#125; catch (JSQLParserException e) &#123;            throw new RuntimeException(e);        &#125;        return processParser(statement, 0, sql, obj);    &#125;    private String processParser(Statement statement, int i, String sql, Object obj) &#123;        if(statement instanceof Select) &#123;            processSelect((Select)statement, i, sql, obj);        &#125;        sql = statement.toString();        return sql;    &#125;    private void processSelect(Select select, int i, String sql, Object obj) &#123;        processSelectBody(select.getSelectBody());        List&lt;WithItem&gt; withItemsList = select.getWithItemsList();        if(withItemsList != null &amp;&amp; !withItemsList.isEmpty()) &#123;            withItemsList.forEach(this::processSelectBody);        &#125;    &#125;    private void processSelectBody(SelectBody selectBody) &#123;        if(selectBody instanceof PlainSelect) &#123;            processPlainSelect((PlainSelect)selectBody);        &#125;else if(selectBody instanceof WithItem)&#123;        &#125;else &#123;        &#125;    &#125;    private void processPlainSelect(PlainSelect plainSelect) &#123;        List&lt;SelectItem&gt; selectItems = plainSelect.getSelectItems();        if(!selectItems.isEmpty()) &#123;            selectItems.forEach(this::processSelectItem);        &#125;        // 处理where        Expression where = plainSelect.getWhere();        processWhereSubSelect(where);        FromItem fromItem = plainSelect.getFromItem();        List&lt;Table&gt; list = processFromItem(fromItem);        List&lt;Table&gt; mainTables = new ArrayList&lt;&gt;(list);        List&lt;Join&gt; joins = plainSelect.getJoins();        if(joins != null &amp;&amp; !joins.isEmpty()) &#123;            mainTables = processJoins(mainTables, joins);        &#125;        if(!mainTables.isEmpty()) &#123;            plainSelect.setWhere(builderExpression(where, mainTables));        &#125;    &#125;    private List&lt;Table&gt; processJoins(List&lt;Table&gt; mainTables, List&lt;Join&gt; joins) &#123;        return new ArrayList&lt;&gt;();    &#125;    private Expression builderExpression(Expression currentExpression, List&lt;Table&gt; mainTables) &#123;        if(mainTables.isEmpty()) return currentExpression;        // 构造expression TODO        Expression equals = new StringValue(&quot;408&quot;);        List&lt;EqualsTo&gt; equalsTos = mainTables.stream().map(item -&gt;                new EqualsTo(getAliasColumn(item), equals)        ).collect(Collectors.toList());        Expression injectExpression = equalsTos.get(0);        if(equalsTos.size() &gt; 1) &#123;            for (int i = 1; i &lt; equalsTos.size(); i++) &#123;                injectExpression = new AndExpression(injectExpression, equalsTos.get(i));            &#125;        &#125;        if(currentExpression == null) return injectExpression;        if(currentExpression instanceof OrExpression) &#123;            return new AndExpression(new Parenthesis(currentExpression), injectExpression);        &#125;else &#123;            return new AndExpression(currentExpression, injectExpression);        &#125;    &#125;    private Expression getAliasColumn(Table item) &#123;        return new Column(&quot;id&quot;);    &#125;    private List&lt;Table&gt; processFromItem(FromItem fromItem) &#123;        while(fromItem instanceof ParenthesisFromItem) &#123;            fromItem = ((ParenthesisFromItem) fromItem).getFromItem();        &#125;        List&lt;Table&gt; mainTables = new ArrayList&lt;&gt;();        if(fromItem instanceof Table) &#123;            Table fromTable = (Table) fromItem;            // 表            mainTables.add(fromTable);        &#125;else if(fromItem instanceof SubJoin)&#123;            List&lt;Table&gt; tables = processSubJoin((SubJoin)fromItem);            mainTables.addAll(tables);        &#125;else &#123;            processOtherFromItem(fromItem);        &#125;        return mainTables;    &#125;    private List&lt;Table&gt; processSubJoin(SubJoin fromItem) &#123;        return new ArrayList&lt;&gt;();    &#125;    private void processOtherFromItem(FromItem fromItem) &#123;    &#125;    private void processWhereSubSelect(Expression where) &#123;    &#125;    private void processSelectItem(SelectItem selectItem) &#123;    &#125;    @Override    public boolean willDoUpdate(Executor executor, MappedStatement ms, Object parameter) throws SQLException &#123;        return InnerInterceptor.super.willDoUpdate(executor, ms, parameter);    &#125;    @Override    public void beforeUpdate(Executor executor, MappedStatement ms, Object parameter) throws SQLException &#123;        InnerInterceptor.super.beforeUpdate(executor, ms, parameter);    &#125;    @Override    public void beforePrepare(StatementHandler sh, Connection connection, Integer transactionTimeout) &#123;        InnerInterceptor.super.beforePrepare(sh, connection, transactionTimeout);    &#125;    @Override    public void beforeGetBoundSql(StatementHandler sh) &#123;        InnerInterceptor.super.beforeGetBoundSql(sh);    &#125;    @Override    public void setProperties(Properties properties) &#123;        InnerInterceptor.super.setProperties(properties);    &#125;&#125;\n","tags":["Spring","MyBatis"]},{"title":"翻译字段使用枚举类型","url":"/2023/02/25/%E7%BF%BB%E8%AF%91%E5%AD%97%E6%AE%B5%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/","content":"枚举类型替换类似Integer type类型字段枚举方案MyBatisplus官方方案\n枚举序列化问题\n在枚举类某方法上使用@JsonValue注解\n\n","tags":["Java","Spring","MyBatis"]},{"title":"获取Request","url":"/2023/02/10/%E8%8E%B7%E5%8F%96Request/","content":"获取HttpServletRequestHttpServletRequest request =                ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes())                .getRequest();\n","tags":["Java","Spring"]}]